//! Learn more about the laws driving the Quantity programming language
//! 
//! # 1. Law of Reality
//! The Law of Reality states that
//! > "All values in `Quantity` represent reality"
//! 
//! No matter what language you program in - if you are working with real values
//! that have a unit with them, it gets stripped away until it is just the magnitude
//! itself. Any conversions have to be explicitly performed and variables have to
//! be cleverly named to ensure that the units in numbers do not get mixed up.
//! 
//! In this language values 
//! 
//! # 1. Law of Brevity
//! The Law of Brevity states that
//! > "Every character in `Quantity` code is important and
//! productive"
//!
//! Many languages nowadays, like Rust, have mechanics in place to help minimize
//! the amount of boilerplate that you write. This is a good and inspiring thing
//! to `Quantity` but it does not go far enough.
//!
//! Every single unnecessary character is a waste of your time. This language is
//! designed to eliminate every character possible without negatively
//! affecting the clarity of your code.
//!
//! # 2. Law of Clarity
//! The Law of Clarity states that
//! > "Code written in `Quantity` explicitly describes itself"
//!
//! While Brevity is a major component of the design of `Quantity`, it is
//! worthless if the end result is not clear. Every aspect of this language is
//! self-explanatory and clear. Once you learn the basics, you will never have
//! to repeat a search again.
//!
//! # 3. Law of Duality
//! The Law of Duality states that
//! > "A `Quantity` program is both compilable and interpretable"
//!
//! Many languages require a trade-off between convenience and runtime
//! performance. Higher-level languages like Julia and Python both support
//! JIT-compilation but that comes at the cost of constant re-compilations.
//! Lower-level languages like Rust have great performance that comes at the
//! cost of a longer development process.
//!
//! `Quantity` bridges the gap between the two groups of languages by natively
//! supporting interpretation and compilation - sometimes within the same process!
//!
//! This support is on a level that no other language has reached before. Rust gets
//! close with its extensive macro system that is pretty much its own language.
//! Imagine writing macros for your code in the same language as the code itself!
//! This functionality is supported in this language.
//!
//! # 4. Law of Omneity
//! The Law of Omneity states that
//! > "All expressions of `Quantity` code are comprehensively defined"
//!
//! With `Quantity`, there is no undefined behavior that you need to be aware of
//! when targeting different systems. One of the great disadvantages of C and C++
//! are the wide range of almost standard-practice techniques that are not technically
//! defined uses of the language. Compilers on different platforms might handle
//! certain blocks of code differently. How can you have confidence in your work
//! with that fact looming on your mind?
//! 
//! In this language - every behavior is fully defined behavior.
//!
//! # Limitations are Few
//! Unlike many other languages, Quantity will not get in your way. It empowers you to
//! write code that you are proud of. Much of the syntax allows for options and different
//! forms
//!
